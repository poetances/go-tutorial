
一、基础语法与数据结构

1. make和 new的区别？
答案：
new(T)：为类型 T分配零值内存，返回指向该内存的指针（*T）。仅分配内存，不初始化（如 new(int)返回 *int，指向值为 0的内存）。
make(T)：仅用于slice、map、channel三种引用类型，分配并初始化内存（如 make([]int, 5)返回长度为5、容量为5的切片），返回类型 T本身（非指针）。
解析：new很少使用，通常用 &T{}替代结构体分配；make是创建引用类型的标准方式，因它们内部有复杂结构（如切片的 len、cap）。
2. Go语言的 slice底层是如何实现的？
答案：

Go的 slice是动态数组的引用，底层是一个结构体（runtime.slice），包含三个字段：
ptr：指向底层数组的指针；
len：当前切片的长度（元素个数）；
cap：切片的容量（底层数组的总长度）。
动态扩容机制：当 append元素超过 cap时，会分配新的底层数组（容量通常翻倍），将原数据复制到新数组，并更新 ptr和 cap。
3. nilslice 和空 slice 有什么区别？
答案：
nilslice：未初始化的切片，slice == nil为 true（如 var s []int）；
空 slice：已初始化但长度为0的切片，slice != nil（如 s := []int{}或 s := make([]int, 0)）。
共同点：两者长度均为0，len()和 cap()均返回0；区别：nilslice 未分配底层数组，空 slice 分配了底层数组（长度为0）。
4. map的底层实现原理是什么？它是线程安全的吗？
答案：
底层实现：Go的 map是哈希表（runtime.hmap），由桶（bucket）数组组成，每个桶存储键值对（最多8个）。哈希冲突通过链地址法解决（桶内链表）。
线程安全：非线程安全。并发读写 map会触发 fatal error: concurrent map read and map write。
线程安全方案：
使用 sync.Map（适合读多写少场景）；
用 sync.Mutex或 sync.RWMutex封装 map（适合写多场景）。
5. for range循环有什么注意事项？
答案：
变量重用：循环中的 i、v是单次迭代重用的（短变量声明 :=），而非每次重新声明。例如：
go
下载
复制
运行
for i, v := range m {
    go func() {
        fmt.Println(i, v) // 输出的是循环结束后的最终值（如 i=2, v=3）
    }()
}
解决：将 i、v作为参数传递给闭包（go func(i, v int) { ... }(i, v)）。
修改原数据：for range遍历 slice时，修改元素值会影响原数据，但修改 slice的长度（如 append）不会影响循环次数（因 len()在循环开始前已确定）。
6. defer的执行顺序和时机？
答案：
执行顺序：defer语句后进先出（LIFO）（最后注册的 defer最先执行）。
执行时机：defer语句在函数返回前执行（无论函数是正常返回还是 panic）。
注意事项：
defer后的函数参数会立即求值（如 defer fmt.Println(i)中的 i是当前值）；
若需修改命名返回值，需使用命名返回值变量（如 defer func() { ret = ret * 2 }()）。
7. struct能不能比较？
答案：
不能直接比较：struct类型不能使用 ==或 !=运算符（编译错误）。
可比较的情况：若 struct的所有字段都是可比较类型（如基本类型、指针、数组、slice除外），则可通过类型转换为 interface{}比较（如 fmt.Println(s1 == s2)不行，但 fmt.Println(s1.(interface{}) == s2.(interface{}))可以，但需注意 slice字段会导致比较失败）。
解决：使用 reflect.DeepEqual（如 reflect.DeepEqual(s1, s2)）比较两个 struct是否相等。
8. Go语言的参数传递是值传递还是引用传递？
答案：
值传递：所有参数传递都是值传递（复制参数的值）。
引用传递的假象：若参数是引用类型（如 slice、map、channel、指针），复制的是引用（如切片的 ptr、len、cap），而非底层数组。因此，修改引用类型的值会影响原数据（如 func modify(s []int) { s[0] = 1 }，原切片的第一个元素会被修改）。
9. interface{}是什么？它和空接口 any有什么关系？
答案：
interface{}：空接口，没有任何方法签名。所有类型都实现了 interface{}（因为空接口没有要求），因此可以存储任意类型的值（如 var i interface{} = 1、i = "hello"）。
any：Go 1.18 引入的类型别名（type any = interface{}），与 interface{}完全等价，只是语法更简洁。
二、并发编程

1. Goroutine 和线程的区别？
答案：
维度​
Goroutine​
线程（OS Thread）​
创建开销​
2-4 KB 栈（动态伸缩）
1-8 MB 栈（内核分配）
调度方式​
用户态（Go 运行时调度，无需内核介入）
内核态（操作系统调度）
切换开销​
低（仅保存 PC/SP 等寄存器）
高（需保存全寄存器+内核态切换）
并发性​
轻量级（可创建百万级）
重量级（受限于内存和内核调度）
阻塞影响​
仅阻塞当前 Goroutine，P 可调度其他 Goroutine
阻塞整个线程，所有 Goroutine 暂停
2. GMP模型是什么？请解释一下G、M、P的含义。
答案：

GMP 是 Go 运行时的并发调度模型，核心组件：
G（Goroutine）：用户态轻量级线程，存储执行上下文（如栈、程序计数器）。
M（Machine）：操作系统线程（OS Thread），由内核调度，执行 G 的代码。
P（Processor）：逻辑处理器，维护 G 的本地运行队列（最多256个 G），控制 M 的执行（M 必须绑定 P 才能执行 G）。
调度流程：
G 启动后，加入 P 的本地队列；
M 绑定 P，从本地队列获取 G 执行；
若本地队列为空，M 从全局队列获取 G，或从其他 P 的本地队列“窃取”（工作窃取）；
G 阻塞（如 I/O）时，M 解绑 P，P 寻找空闲 M 或创建新 M；
G 恢复执行时，加入 P 的本地队列，等待 M 绑定。
3. sync.Mutex和 sync.RWMutex的区别？
答案：
sync.Mutex：互斥锁，同一时间只允许一个 Goroutine 访问共享资源（无论读写）。
使用场景：写操作频繁或读写操作都需要互斥的场景。
sync.RWMutex：读写锁，允许多个 Goroutine 同时读，但只允许一个 Goroutine 写。
方法：
RLock()/RUnlock()：读锁（共享）；
Lock()/Unlock()：写锁（独占）。
使用场景：读多写少的场景（如缓存）。
注意事项：
锁的粒度要小（尽量缩短锁的持有时间）；
避免死锁（如锁未释放就返回）。
4. Channel 的作用和底层原理？
答案：
作用：
通信：Goroutine 之间传递数据（“不要通过共享内存来通信，而要通过通信来共享内存”）；
同步：协调 Goroutine 的执行顺序（如 chan done := make(chan bool)，子 Goroutine 完成后发送 done <- true，主 Goroutine 接收 <-done等待）。
底层原理：Channel 是环形队列（runtime.hchan），包含：
buf：环形队列（存储数据）；
sendx/recvx：发送/接收索引；
mutex：互斥锁（保证并发安全）；
sendq/recvq：等待发送/接收的 Goroutine 队列（处理阻塞情况）。
5. 有缓冲和无缓冲Channel的区别和使用场景？
答案：
维度​
无缓冲Channel​
有缓冲Channel​
定义​
ch := make(chan int)
ch := make(chan int, 5)
阻塞条件​
发送和接收必须同时就绪（否则阻塞）
发送：队列未满时不阻塞；接收：队列非空时不阻塞
使用场景​
强同步（如信号通知、等待结果）
弱同步（如生产者-消费者模型，缓冲数据）
6. select语句的作用是什么？
答案：

select语句用于监听多个 Channel 的操作（发送或接收），直到其中一个 Channel 就绪（类似 switch，但每个 case都是 Channel 操作）。

特点：
若多个 case同时就绪，随机选择一个执行（避免饥饿）；
若有 default分支，非阻塞（所有 case都不就绪时执行 default）；
若没有 default分支，阻塞直到某个 case就绪。
示例：
go
下载
复制
运行
select {
case msg := <-ch1:
    fmt.Println("Received from ch1:", msg)
case msg := <-ch2:
    fmt.Println("Received from ch2:", msg)
default:
    fmt.Println("No message received")
}

7. 如何实现一个超时控制？
答案：

使用 select语句结合 time.After实现超时控制（最常用）。

示例（等待 Channel 数据，超时1秒）：
go
下载
复制
运行
func main() {
    ch := make(chan int)
    go func() {
        time.Sleep(2 * time.Second)
        ch <- 1
    }()

    select {
    case res := <-ch:
        fmt.Println("Received:", res)
    case <-time.After(1 * time.Second):
        fmt.Println("Timeout")
    }
}
输出：Timeout（因 ch2秒后才会发送数据，超过1秒超时）。

8. context.Context包的作用？
答案：

context包用于控制 Goroutine 的生命周期（取消、超时、传递值），解决Goroutine 泄漏问题（如子 Goroutine 无法终止）。

核心功能：
取消信号：通过 context.WithCancel创建可取消的 context，调用 cancel()发送取消信号，所有监听该 context的 Goroutine 都会收到通知；
超时控制：通过 context.WithTimeout创建带超时的 context，超时后自动发送取消信号；
值传递：通过 context.WithValue传递请求范围的值（如请求ID、Token）。
示例（取消子 Goroutine）：
go
下载
复制
运行
func worker(ctx context.Context) {
    for {
        select {
        case <-ctx.Done(): // 收到取消信号
            fmt.Println("Worker stopped")
            return
        default:
            fmt.Println("Working...")
            time.Sleep(500 * time.Millisecond)
        }
    }
}

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    go worker(ctx)

    time.Sleep(2 * time.Second)
    cancel() // 发送取消信号
    time.Sleep(500 * time.Millisecond)
}
输出：
复制
Working...
Working...
Working...
Worker stopped

9. atomic包和锁的区别？
答案：
atomic包：通过硬件指令（如 CAS，Compare-And-Swap）实现原子操作（如 atomic.AddInt32、atomic.LoadPointer），适用于简单的读写操作（如计数器）。
优点：无锁，性能高；
缺点：只能操作单个变量，无法处理复杂逻辑（如多个变量的原子更新）。
锁（如 sync.Mutex）：通过互斥实现临界区保护，适用于复杂逻辑（如多个变量的修改、资源访问）。
优点：功能强大，支持复杂逻辑；
缺点：有锁开销，性能低于原子操作。
选择建议：
简单读写（如计数器）：用 atomic；
复杂逻辑（如缓存更新）：用锁。
10. 什么是竞态条件？如何检测？
答案：
竞态条件（Race Condition）：多个 Goroutine 并发访问共享资源（如变量、文件），且至少一个访问是写操作，导致结果依赖于访问顺序（如 i++操作，多个 Goroutine 并发执行会导致结果小于预期）。
检测方法：
使用 -race标志编译运行（go run -race main.go），Go 的竞态检测器会报告竞态条件的位置；
使用 sync.Mutex或 atomic包避免竞态条件。
11. sync.Once的作用是什么？它是如何实现的？
答案：
作用：确保某个函数只执行一次（无论有多少个 Goroutine 调用），适用于单例模式（如初始化全局配置）。
实现原理：通过 sync.Mutex和 atomic包实现：
done：uint32类型，标记函数是否已执行（0：未执行，1：已执行）；
m：sync.Mutex，保证并发安全；
执行函数前，先检查 done（原子操作），若未执行则加锁执行，执行后将 done设为1。
12. WaitGroup的使用场景和注意事项？
答案：
作用：等待一组 Goroutine 完成（主 Goroutine 等待子 Goroutine 结束）。
使用场景：主 Goroutine 需要等待所有子 Goroutine 完成后再执行（如批量处理任务）。
注意事项：
Add(delta int)：添加等待的 Goroutine 数量（delta必须为正数，且在 Wait()前调用）；
Done()：标记一个 Goroutine 完成（相当于 Add(-1)）；
Wait()：阻塞主 Goroutine，直到所有 Goroutine 完成（Done()被调用 Add()次）。